# OOP의 5원칙과 4가지 특징

<br>

## OOP(Object Oriented Programming, 객체지향 프로그래밍)
- 클래스를 사용하여 추상적인 개념들을 정의하고, 그 클래스를 사용하여 실제로 사용할 객체를 만들어내는 프로그래밍 방식

<br>

## OOP의 5원칙, SOLID

### 1. SRP(Single Responsibility Principle, 단일 책임 원칙)
- 하나의 모듈(Class)은 한 가지 책임(기능)을 가져야 한다.
- 만약 단일 책임 원칙을 지키지 않았을 경우에는 해당 Class를 수정했을 때 다른 모듈에 어떠한 영향을 미치는지 그 범위를 추측하기 힘들 수 있다.

<br>

### 2. OCP(Open/Closed Principle, 개방-폐쇄 원칙)
- 확장에는 열려 있으나, 변경에는 닫혀 있어야 한다.
- 확장에 열려있다는 것 : 요구사항이 변경될 때 새로운 기능을 추가하여 확장할 수 있다.
- 변경에 닫혀있다는 것 : 기존의 코드를 수정하지 않고 기능을 추가 또는 변경할 수 있어야 한다.

<img width="400" height="300" src="https://user-images.githubusercontent.com/50553183/198191184-e9a29a77-782e-400c-b282-5e53a4c7356f.png">


<br>

### 3. LSP(Liskov’s Substitution Principle, 리스코프 치환 원칙)
- LSP는 상속에 대한 개념으로, 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
- 예를 들어 자전거 인터페이스의 브레이크는 정지하는 기능인데, 앞으로 가게 구현한다면 LSP를 위반하는 것이다.<br>
  만약, 브레이크가 느리게 정지하더라도 정지하는 기능은 일치해야 한다.

<br>

### 4. ISP(Interface Segregation Principle, 인터페이스 분리 원칙)
- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
- 큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리시킴으로써 꼭 필요한 메소드들만 이용할 수 있게 한다.

<br>

### 5. DIP(Dependency Inversion Principle, 의존 역전 원칙)
- 구체화가 아닌 추상화에 의존해야 한다.
- DIP를 따르면 유연하게 구현체를 변경할 수 있다.

[DIP 원칙을 따르지 않은 경우]
<br>
<br>
<img width="300" height="50" src="https://user-images.githubusercontent.com/50553183/198191200-a615acc6-5dba-47ac-a103-d62b486a2d94.png">

[DIP 원칙을 따르는 경우]
<br>
<br>
<img width="400" height="150" src="https://user-images.githubusercontent.com/50553183/198191207-5382d6f1-77cd-444e-bebc-021421c734bf.png">


<br>

## OOP의 4가지 특징

### 1. 캡슐화
- 실제 구현 부분을 외부에 드러나지 않도록 하는 것
- 데이터를 외부에서 직접 접근하지 않고 함수를 통해서만 접근한다.

<br>

### 2. 상속
- 자식 클래스가 부모 클래스의 특성과 기능을 물려받는 것
- 기능의 일부분을 변경하는 경우 자식 클래스에서 상속받아서 수정 후 사용한다.
- 상속은 캡슐화를 유지, 클래스의 재사용이 용이하도록 해준다.

<br>

### 3. 추상화
- 인터페이스로 클래스들의 공통적인 특성(변수, 메소드)들을 묶어 표현하는 것

<br>

### 4. 다형성
- 어떤 변수, 메소드가 상황에 따라 다른 결과를 내는 것
- 다형성의 개념을 녹여내는 방법은 오버라이딩(Overriding), 오버로딩(Overloading) 2가지이다.
* **오버로딩(Overloading)** : 하나의 클래스에서 메소드의 이름이 같지만, 파라미터가 다른 것
* **오버라이딩(Overriding)** : 부모 클래스의 메소드를 자식 클래스의 용도에 맞게 재정의하여 코드의 재사용성을 높임

<br>
<br>
