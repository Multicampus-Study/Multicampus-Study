# 인덱스(INDEX)

<br>

## 인덱스란?

<img height="300" width="600" src="https://user-images.githubusercontent.com/50553183/192446398-39a1c8e0-de74-42e2-832a-bed8f45b58c3.png">

- 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다.
- 데이터베이스에서 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회하도록 돕는다.
- 인덱스를 활용하면, 데이터를 조회하는 SELECT 외에도 UPDATE나 DELETE의 성능이 함께 향상된다.

<br>

## 인덱스의 관리
- DBMS는 index를 항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다.
<br>

- **INSERT** : 새로운 데이터에 대한 인덱스를 추가
- **DELETE** : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행
- **UPDATE** : 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가

<br>

## 인덱스의 장점과 단점
- 장점
	- 테이블의 조회하는 속도와 성능을 향상시킬 수 있다.
	- 전반적인 시스템의 부하를 줄일 수 있다.
	- 데이터들이 정렬되어 있어 조건 검색 WHERE 절이 효율적 / <br>
	  부하가 많이 걸리는 작업인 ORDER BY에 의한 정렬을 피할 수 있음 / <br>
    MIN,MAX 값 처리 쉬움
- 단점
	- 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
	- 인덱스를 관리하기 위해 추가작업이 필요하다.
	- 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.
	- (CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게되면 인덱스의 크기가 비대해져서 성능이 오히려 저하된다.)

<br>

## 인덱스 생성 전략
- 인덱스는 특정 컬럼을 기준으로 생성하고 기준이 된 컬럼으로 정렬된 인덱스 테이블이 생성된다.

- 규모가 작지 않은 테이블
- 가장 최선은 PK를 인덱스로 설정
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 칼럼
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 칼럼
- 중복되는 데이터가 최소한이 칼럼

<br>

## 인덱스의 자료구조

### 해시 테이블
![해시](https://user-images.githubusercontent.com/50553183/192459508-8b32755d-bf3b-4891-8fda-c0971dc7b9ab.png)

- 해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용하다.
- 해시 테이블 기반의 DB 인덱스는 (컬럼값, 데이터의 위치)를 (Key,Value)값으로 사용하여 컬럼의 값으로 생성된 해시를 통해 인덱스를 구현하였다.
- 하지만 해시는 등호 연산에만 특화되어있기 때문에 부등호 연산(<.>)이 자주 사용되는 데이터베이스 검색에는 적합하지 않다.

<br>

### B+Tree

<img width="65%" src="https://user-images.githubusercontent.com/50553183/192449310-771f09b6-1ff7-4e26-ab77-5d881353a704.png">
<img width="65%" src="https://user-images.githubusercontent.com/50553183/192449370-28b975d2-a86d-432b-9ac1-a219fe49a14f.png">

<br>

- B+Tree는 DB의 인덱스를 위해 B-Tree를 개선시킨 자료구조이다.
- B+Tree는 모든 노드에 데이터(Value)를 저장했던 B-Tree와 다른 특성을 가지고 있다.
	- 리프노드(데이터노드)만 인덱스와 함께 데이터(Value)를 가지고 있고, <br>
	  나머지 노드(인덱스노드)들은 데이터를 위한 인덱스(Key)만을 갖는다.
	- 리프노드들은 LinkedList로 연결되어 있다.
	- 데이터 노드 크기는 인덱스 노드의 크기와 같지 않아도 된다.
- leaf node를 제외하고 데이터를 저장하지 않기 때문에 메모리를 더 확보할 수 있다. <br>
  따라서 하나의 node에 더 많은 포인터를 가질 수 있기 때문에 트리의 높이가 더 낮아지므로 검색 속도를 높일 수 있다.
- Full scan을 하는 경우 B+Tree는 leaf node에만 데이터가 저장되어 있고, <br>
  leaf node끼리 linked list로 연결되어 있기 때문에 선형 시간이 소모된다. <br>
  반면 B-Tree는 모든 node를 확인해야 한다. 
- 반면, B-Tree의 경우 최상의 경우 특정 key를 root node에서 찾을 수 있지만, <br>
  B+Tree의 경우 반드시 특정 key에 접근하기 위해서 leaf node까지 가야 하는 단점이 있다.  


<br>
