# 페이징 & 세그먼테이션

<br>

### 페이징(Paging)

<p align="center">
<img src="https://user-images.githubusercontent.com/66001046/196350453-74db50c3-1946-49ba-adb6-2484c6fd730a.png">
</p>

- 프로세스의 주소 공간을 고정된 사이즈의 페이지 단위로 나누어 물리적 메모리에 불연속적으로 할당하는 방식
- 메모리는 Frame이라는 고정크기로 분할되고, 프로세스는 Page 라는 고정크기로 분할된다.
- 페이지와 프레임의 크기가 같다.
- 페이지와 프레임을 대응시키는 page mapping 과정이 필요하며 paging table을 생성해야 한다.
- 연속적이지 않은 공간도 활용할 수 있기 때문에 외부 단편화 문제가 해결된다.
- 페이지 테이블에는 각 페이지 번호와 해당 페이지가 할당된 프레임의 시작 물리 주소를 저장한다.

<br>

### 세그먼테이션(Segmentation)

<p align="center">
<img src="https://user-images.githubusercontent.com/66001046/196350518-7d513a65-3230-4861-a8aa-fbfcd6c96ad7.png">
</p>

- 프로세스를 서로 크기가 다른 논리적인 블록 단위인 세그먼트(Segment)로 분할하여 메모리를 생성한다.
- 각 세그먼트는 연속적인 공간에 저장한다.
- 세그먼트들의 크기가 서로 다르기 때문에 프로세스가 메모리에 적재될 때 빈 공간을 찾아 할당하는 기법이다.
- 페이징과 마찬가지로 mapping을 위한 세그먼트 테이블이 필요하다.

<br>

### 페이징 vs 세그먼테이션

- **페이징**은 고정크기를 가진다.
- **세그먼테이션**은 가변 크기를 가진다.
- **페이징**은 내부 단편화 발생 가능, **세그먼테이션**은 외부 단편화 발생 가능

세그먼테이션은 페이징과 유사하고 보호와 공유 측면에서는 더 나은 성능을 보여주었지만, **현재 대부분 페이징 기법을 사용한다.**<br>
그 이유는, **세그먼테이션에는 치명적인 단점이 존재하기 때문이다.**

메모리 할당을 처음 시작할 때, 다중 프로그래밍에서의 문제는 크기가 서로 다른 프로세스로 인해 여러 크기의 hole이 발생한다. 이로 인해 어느 hole에 프로세스를 할당하는 것에 대한 최적화 알고리즘이 존재하지 않고, 외부 단편화로 인해 메모리 낭비가 크다고 했었다.

세그먼테이션도 똑같은 문제점이 발생한다. 왜냐하면 세그먼테이션은 논리적인 단위로 나누기 때문에 세그먼트의 크기가 다양하다. 이로 인해 다양한 크기의 hole이 발생하므로 같은 문제가 발생한다.

결론적으로,

**세그먼테이션**은 보호와 공유에서 효율적이고, **페이징**은 외부 단편화 문제를 해결할 수 있다. 그러므로 이 두가지를 합쳐서 사용하는 방법이 나왔다. 두 장점을 합치기 위해서는 **세그먼트를 페이징 기법으로 나누는 것이다. (Paged Segmentation)**

<br><br><br>

---

##### 참고사이트
1. https://gyoogle.dev/blog/interview/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C.html
2. https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-13.-%ED%8E%98%EC%9D%B4%EC%A7%95
