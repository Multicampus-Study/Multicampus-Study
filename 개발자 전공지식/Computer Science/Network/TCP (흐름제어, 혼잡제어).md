# TCP(흐름제어, 혼잡제어)
<br>

## 흐름제어
- 송신 측과 수신 측 데이터 처리 속도 차이를 해결하기 위한 기법
- 수신 측이 송신 측보다 데이터 처리 속도가 빠르다면 문제가 없지만, 송신 측의 속도가 빠를 경우 문제가 생긴다.
- 수신 측에서 제한된 저장 용량을 초과한 이후에 도착하는 패킷은 손실될 수 있으며, 만약 손실된다면 불필요한 추가 패킷 전송이 발생하게 된다.

<br>

> #### TCP 버퍼
> 
<img width="500" alt="버퍼" src="https://user-images.githubusercontent.com/50553183/177698144-29e1e971-9ba1-430b-89df-0d689499da65.png">

송신 측은 버퍼에 TCP 세그먼트를 보관한 후 순차적으로 전송하고, 수신 측은 도착한 TCP 세그먼트를 애플리케이션이 읽을 때까지 버퍼에 보관한다.

### 흐름제어 기법
### 1. Stop and Wait
<img width="200" height="300" alt="stop and wait" src="https://user-images.githubusercontent.com/50553183/177698574-9ed97093-85be-4f3b-990f-304f122f5c15.png">

- 매번 전송한 패킷에 대해 확인 응답(ACK)를 받으면 다음 패킷을 전송하는 방법
- 패킷을 하나씩 보내기 때문에 비효율적인 방법
<br>

### 2. Sliding Window

<br>

> #### 윈도우(window) 크기
최초의 윈도우 크기는 호스트들의 '3 way handshaking'을 통해 수신 측 윈도우 크기로 설정
<br>
이후 수신 측의 버퍼에 남아있는 공간에 따라 변한다. 
<br>
윈도우 크기는 수신 측에서 송신 측으로 확인 응답(ACK)을 보낼 때 TCP 헤더(window size)에 담아서 보낸다.

<br>
<br>
<img height="300" width="500" src="https://user-images.githubusercontent.com/50553183/177701283-a664eb57-764a-469b-b29c-4737669049b3.png">

- 윈도우에 포함된 패킷을 계속 전송하고, 수신 측으로부터 확인 응답(ACK)이 오면 윈도우를 옆으로 옮겨 다음 패킷들을 전송한다.
  - 최초로 수신자는 윈도우 사이즈를 7로 정한다.
  - 송신자는 수신자의 확인 응답(ACK)를 받기 전까지 데이터를 보낸다.
  - 수신자는 확인응답(ACK)을 송신자에게 보내면, 슬라이딩 윈도우 사이즈를 충족할 수 있게끔 윈도우를 옆으로 옮긴다.
  - 이후 데이터를 다 받을 때까지 위 과정을 반복한다.
  - 만약 일정 시간동안 수신측으로부터 확인응답(ACK)을 받지 못하면 수신 측의 윈도우 사이즈를 확인한 후, 패킷을 재전송한다.

<br>
<br>

## 혼잡제어
- 송신측의 데이터 전달과 네트워크 데이터 처리 속도 차이를 해결하기 위한 기법
- 데이터의 양이 라우터가 처리할 수 있는 양을 초과하면 초과된 데이터는 라우터가 처리하지 못한다. 이때 송신 측에서는 라우터가 처리하지 못한 데이터를 손실 데이터로 간주하고 계속 재전송하여 네트워크를 혼잡하게 한다.
- 이런 상황은 송신 측의 전송 속도를 적절히 조절하여 예방할 수 있는데, 이것을 혼잡 제어라고 한다.

### 혼잡제어 기법
### 1. AIMD(Additive Increase/Multicative Decrease)

<img width="500" height="300" src="https://user-images.githubusercontent.com/50553183/177702735-64222fa1-256d-4efa-9885-04da69d8b408.png">

- 처음에 패킷을 하나씩 보내고 문제 없이 도착하면 윈도우의 크기를 1씩 증가시켜가며 전송한다.
- 만약, 전송에 실패하면 윈도우 크기를 반으로 줄인다.
- 윈도우 크기를 너무 조금씩 늘리기 때문에 네트워크의 모든 대역을 활용하여 제대로 된 속도로 통신하기까지 시간이 오래 걸린다는 단점이 있다.

<br>

### 2. 느린 시작(Slow Start)
- 윈도우의 크기를 1, 2, 4, 8, ...과 같이 지수적으로 증가시키다가 혼잡이 감지되면 윈도우 크기를 1로 줄인다.
- 보낸 데이터의 ACK가 도착할 때마다 윈도우 크기를 증가시키기 때문에 처음에는 윈도우 크기가 조금 느리게 증가할지라도, 시간이 가면 갈수록 윈도우 크기가 점점 빠르게 증가한다는 장점이 있다.

<br>

> #### Slow Start 임계점 (ssthresh)

<img height="300" weight="500" src="https://user-images.githubusercontent.com/50553183/177708537-404fd33d-d25f-4951-bab4-227c82411c9a.png">

- Slow Start Threshold(ssthresh) 를 뜻하는 것으로, 여기까지만 Slow Start를 사용하겠다는 의미
- Slow Start를 사용하며 윈도우 크기를 지수적으로 증가시키다보면 어느 순간부터는 윈도우 크기가 기하급수적으로 늘어나서 제어하기가 힘들다.
- 그래서 특정한 임계점을 정해 놓고, 그 임계점이 넘어가면 AIMD 방식을 사용하여 선형적으로 윈도우를 증가시킨다. 


<br>

### 3. 빠른 재전송(Fast Retransmit)

<img width="500" height="300" src="https://user-images.githubusercontent.com/50553183/177705283-b532da66-39ac-423f-966e-cfebb3e4bd61.png">

- 패킷을 받는 수신자 입장에서는 세그먼트로 분할된 내용들이 순서대로 도착하지 않는 경우가 생길 수 있다. 
- 이런 상황이 발생했을 때 수신 측에서는 순서대로 잘 도착한 마지막 패킷의 다음 순번을 ACK 패킷에 실어서 보낸다. 
- 그리고 이런 중복 ACK를 3개 받으면 재전송이 이루어진다.
- 송신 측은 자신이 설정한 타임 아웃 시간이 지나지 않았어도 바로 해당 패킷을 재전송할 수 있기 때문에 보다 빠른 재전송률을 유지할 수 있다.
- 또, 혼잡을 감지하고 window size를 줄이게 된다.

<br>

### 4. 빠른 회복(Fast Recovery)
- 혼잡한 상태가 되면 윈도우 크기를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방법이다
- 혼잡 상황을 한 번 겪고나서부터는 AIMD 방식으로 동작한다.

<br>

### 혼잡제어 정책
### 1. TCP Tahoe

<img width="500" height="300" src="https://user-images.githubusercontent.com/50553183/177709681-55666327-8cbd-4cb8-a903-a9bf77211d7d.png">

- 처음에는 Slow Start를 사용하다가 임계점에 도달하면 AIMD 방식을 사용한다.
- 그러다가 3 ACK Duplicated 또는 타임아웃이 발생하면 혼잡이라고 판단하여 임계점은 혼잡이 발생한 윈도우 크기의 절반으로, 윈도우 크기는 1로 줄인다.
- 이 방식은 혼잡 이후 Slow Start 구간에서 윈도우 크기를 키울 때 너무 오래걸린다는 단점이 있다.

<br>

### 2. TCP Reno
<img width="500" height="300" src="https://user-images.githubusercontent.com/50553183/177709693-69973df9-2d77-4687-b49d-9e6e7619c772.png">

- TCP Tahoe와의 차이점은 바로 3 ACK Duplicaed와 타임아웃을 구분한다는 점이다.
- TCP Reno는 3 ACK Duplicated가 발생하면 빠른회복 방식을 사용한다. 그리고 임계점을 줄어든 윈도우 값으로 설정한다.
- 만약, 타임아웃이 발생하면 TCP Tahoe와 마찬가지로 윈도우 크기를 1로 줄이고 Slow Start를 진행한다. 이때는 임계점을 변경하지 않는다.
