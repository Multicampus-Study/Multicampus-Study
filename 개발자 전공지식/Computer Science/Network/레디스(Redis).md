# 레디스(Redis)
> ‘Key-Value’ 구조의 비정형 데이터를 저장하고 관리하기 위한 오픈소스 기반의 비관계형 데이터베이스관리 시스템(DBMS)

<br>

## 레디스의 특징 : In-memory 저장 방식
<img width="500" height="300" src="https://user-images.githubusercontent.com/50553183/183946737-5f62c43e-8ed0-4987-8aba-7a46f26d33dc.png">

- 일반적으로 mysql, oracle 등의 RDB들이 하드디스크에 데이터를 저장하고 관리하는 것과 달리 레디스는 데이터를 주기억장치인 RAM, 즉 In-memory에서 관리한다.
- 데이터를 저장하고 조회할 때, 하드디스크를 오고 가는 과정을 거치지 않고 메모리 내부에서 처리되므로 **기존 RDB보다 훨씬 빠른 성능**을 가진다.
- 하지만 서버 장애가 발생할 경우, **데이터 유실이 발생**할 수 있다.
- 서버의 메모리 용량을 초과하는 데이터를 Redis에서 처리할 경우, 서버 자체에 문제가 생길 수도 있다. (RAM의 용량은 그리 크지 않음)

--> 이런 특징으로 **Redis는 전체 서비스에서 속도 향상을 위한 보조 데이터베이스로 사용되는 것이 보편적**이다.

<br>

## 레디스 데이터 구조
<img height="400" width="600" src="https://user-images.githubusercontent.com/50553183/183947515-ceaf5917-eb4d-475a-b3bc-2e28b5bca445.png">

- String, Set, Sorted Set, Hash, List 등의 타입을 지원한다.
- 레디스가 다른 In-Memory 데이터베이스와 가장 큰 차이점은 다양한 자료구조를 지원한다는 것이다.
- 특히 리스트, 배열과 같은 데이터들을 처리하는데 유용하다.
  (리스트형 데이터 입력과 삭제가 MySql에 비해 10배정도 빠르다.)
```
# String형 데이터
SET name Lee
SET name Redis
GET name  
# “LeeRedis” 출력

# List형 데이터
LPUSH myList “a”
LPUSH myList “b”
RPUSH myList “c”
LRANGE myList 0 –1
# 1) “b”
# 2) “a”
# 3) “c”
```
<br>

## 레디스의 데이터 보존 방법
- 데이터를 디스크에서 읽어서 메모리에 올릴 수 있기 때문에 서버가 내려갔다가 올라간 후에도 데이터가 유실되지 않는다.
### 1. Snapshot
- 메모리에 있는 데이터들을 디스크에 옮겨 담는 방식
- 메모리의 상태를 그대로 뜬 것이기 때문에 특정 시점의 백업 및 복구가 유리하고, AOF 방식에 비해 더 빠르게 데이터를 메모리에 올릴 수 있다.
- 서버가 다운되면 백업된 스냅샷 사이에 변경된 데이터들이 유실되는 단점이 있다.
- 확장자 : .rdb
### 2. AOF(Append Only File)
- Redis의 모든 write/update 연산 자체를 모두 log 파일의 형태로 기록하는 방법
- 서버가 실행되면 순차적으로 연산을 재실행하여 데이터를 복구한다.
- 연산 작업이 실행될 때마다 기록하기 때문에 현재 시점까지의 로그를 남길 수 있다.
- 모든 연산에 대해서 로그를 남기기 때문에 데이터의 양이 매우 크고 서버 재시작시 모든 연산을 다시 수행하기 때문에 restart 속도가 느리다.
- 확장자 : .aof

--> 주기적으로 Snapshot으로 백업을 하고 백업 주기 사이의 간격에는 aof 방식으로 수행하는 것이 바람직하다.

<br>

## 사용예시
- 운영 중인 웹 서버에서 키-값 형태의 데이터 타입을 처리해야 하고, I/O가 빈번히 발생해 다른 저장 방식을 사용하면 효율이 떨어지는 경우에 사용한다.
- 대형 서비스 업체들(페이스북, 인스타그램, 네이버 LINE 서비스, StackOverFlow, 블리자드 등)이 사용자들의 대규모 메시지를 실시간으로 처리하기 위하여 사용하고 있다.
- Ex) 유튜브 조회수

<br>

## 사용시 주의할 점
### 1. 메모리 파편화
<img height="300" width="400" src="https://user-images.githubusercontent.com/50553183/183951490-bfb52c35-5c2a-4c30-96f6-280cfb37d0ff.png">

- 메모리를 할당하고 해제하는 과정에서 위 그림과 같이 메모리 파편화가 발생할 수 있다. 
- 따라서 메모리 공간을 할당하지 못해 프로세스가 죽는 문제가 발생할 수 있다.
- 다양한 사이즈를 가지는 데이터보다는 유사한 크기의 데이터를 가지는 경우가 유리하다.
- 큰 메모리를 사용하는 하나의 인스턴스 보다는 적은 메모리를 사용하는 여러개의 인스턴스가 안전하다.
### 2. 싱글스레드
- 레디스는 싱글스레드(한번에 하나의 명령어만 처리)로 동작한다.
- 처리 시간이 긴 명령어가 들어올 경우 다른 명령어들을 처리할 수 없는 상태가 된다.
- 왠만하면 처리 시간이 긴 명령어를 피하고 O(1)으로 동작하는 명령어를 실행시키는 것을 권고한다.
